# -*- coding: utf-8 -*-
"""PYTHON-TELUSKO

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qugdZuNN0IkTsgIySrRodug_S8sxrcuD

#VARIABLE
"""

x = 2 
# x is a variable (container) where we have stored value 2 
# this is just an assignment and doesnt print anythin
y = 4
x + y
#will print addition of two numbers
#always define a variable before use
# _ + 4 = underscore gives ans of previous result

name = 'rocks'
name[0] 
#prints r 
name[4]
#prints s
name = 'youtube'
name[-1]
#prints last digit 
name[0:2]
# 'yo'
name[2:]
#from 2 till end
name[:4]
#from start till 3
name[0:3] = 'my'
#cant change like this because strings are immutable

"""NAMING A VARIABLE"""

# 2b = 4 
# b@ = 6
# this can't be a variable name

# allowed names 
_b = 5
b2 = 4

#  Variable names can contain letters, numbers, and underscores.
# They cannot contain spaces. 
# Variable names cannot start with a number. 
# Variable names are case-sensitive. For example:- The variable names Temp and temp are different.

"""# LISTS"""

nums = [2, 4, 5, 6, 'subbu']
# can have different data types inside lists

nums

nums[-1:]
#slicing operation

nums[-2:]

nums[-1]

nums[2:]

nums[1] = 4
nums
# lists are mutable

names = ['mani' , 'kiran']
mil = [nums,names]
mil
# lists can store another lists

mil[0]

mil[0][2]
# we can access the element inside a list inside another list with this syntax
# also use in matrix representation

"""inbuilt functions in python lists"""

nums.append(3)
nums

nums.insert(2,77)
nums

nums.remove(77)
nums

nums.pop(4)
nums

nums.pop()
nums
# without index itll remove just the last element like a stack

nums.count(2)
# counts numbers of elements = 2 in the list

nums.sort()
nums
# gives the sorted list

del nums[2:]
nums
# deletes all elements after from index value

nums.extend([26,90])
nums
# will just add these list at the end of the given list

min(nums)
max(nums)
sum(nums)



"""#TUPLES"""

#IMMUTABLES
tup = (21,36,14,25)
tup[1]
# tup[3] = 45 #wont work


# in iteration , tuples are faster than lists

"""inbuilt functions"""

tup.count(21)
#counts
tup.index(36)
#gives back index of the given element

"""#SET"""

s = {22,25,14,21,5}
s
#uses hash principle

y = {25,14,98,63,75,98}
y
# doesn't always gives a sorted one

y[2]
#doesnt support indexing
#just supports elements 
# no sequence



"""# DICTIONARY"""

# KEY VALUE PAIR 
data = {1:'subbu' , 2:'kiran', 3:'mani'}
data

data[3]
# values are obtained using keys rather than index

data[3] = 'ravi'

data
# these are mutable

"""inbuilt functions"""

details = {'name': 'navin', 'age': '20', 'height': '180'}
details.items() # gives key value pair as tuples

data.get(1)

data.get(4)
# we wont get error

data.get(4,'not found')

data

## can create dictionaries like this too
keys = ['subbu', 'kiran','ravi']
values = ['python','bigdata','ML']
data1 = dict(zip(keys,values))

data1

# adding data here 
data1['Monika'] = 'AI'
data1

#deleting
del data1['subbu']
data1

# list inside dictionary
data1['list'] = [1,2,3,4]
data1

data1['list'][2]



"""# PYTHON IN CMD PROMPT AND HELP()


"""

help()
#can read all the doc on all inbuit functions
#can also give arguments for specific topics

"""# MORE ON VARIABLES """

num = 5 
# num will have a box in which 5 will be stored and itll have an ID too 
id(num)

# every varible will have diff address
a = 10
b = a 
id(a)

id(b)

# but is values of two variables are same , they will be stored in same place 
# that is both variables will have same place
#python is memory efficient

id(10)

# address is based on the box
k = 10
id(k)

a = 9
id(a)

id(b)
# id of b is still the same

type(b)
#data types

help('type')



"""#DATA TYPES"""

# classification or categorization of data items
 # represent a kind of value that determines what operations can be performed on that data

## none , numeric , list , tuple , set , string, range, dictionary 
#none = varible without any value

"""numeric data types"""

# numeric = int,float,complex,bool
a = 2
b = 2.5
c = 9+4j
d = True

isinstance(b,float)

type(c)

type(d)

"""Data type conversion"""

b = int(b)
type(b)

a = float(a)
type(a)

k = complex(b,a)
k

b<a

value = b<a
type(value)

"""sequence data types"""

# list , tuple , set, string , range

s = []
type(s)

y = {}
type(y)

b = ()
type(b)

k = ''
type(k)

# range is only there in python
range(10)

list(range(10))

list(range(2,11,2))

"""Unordered """

# dictionary is an unordered data type
# key value pair
# all keys shd be unique, usually denoted by sets
# values can change

"""# OPERATORS




"""

x = 3
y = 4

"""ARITHMATIC OPERATORS"""

x+y

x-y

x*y

x = x +2
x

x+=2
x

x *= 3
x

a,b = 5,6

n = 7
-n

"""RELATIONAL OPERATORS"""

a<b

a>b

a==b

a!=b

a>=b

a<=b

"""LOGICAL OPERATORS"""

# AND OR NOT

a = 5
b = 4

a<8 and b >3

a<7 or b<2

x = True

not x

y = b>3
a<7 and not y

"""#NUMBER CONVERSION"""

# BINARY, OCTAL , HEXA , DECIMAL

bin(25)

oct(5)

0b11001

oct(25)

0o31

type(0o31)

y = 0o31
y

type(y)

hex(25)



"""#SWAP TWO NUMBERS """

a = 5
b = 6

#use 3rd variable 
c= a
a = b 
b = c

a

b

# here we are wasting a variable ( memory )
# instead
a = a+b
b = a-b
a = a-b
print(a,b)
# here we used a+b which also increases the memory

# ^ is xor
a = a^b
b = a^b
a = a^b
print(a,b)

"""ROTATION TWO METHOD"""

#yet another way
c = 9
t = 3
c,t = t, c
print(c)
print(t)
# rotation two method

"""# BITWISE OPERATORS"""

# COMPLEMENT(~)
#AND(&)
# OR (|)
# XOR(^)
# LEFTSHIFT(<<)
# RIGHTSHIFT(>>)

"""COMPLEMENT ~"""

~12

#COMPLEMENT OF THE BINARY NUMBER
# 2's complement = 1's complement +1 = 1's complement(13) +1 = 11110010 +1 
# = 11110011 which is -13 which is also 12

"""BITWISE AND &"""

12 & 13

bin(12)

bin(13)

# and operation of binary numbers of 12 and 13 gives 12
# 1100 and 1101 = 1100

"""OR |"""

12|13
# 1100 or 1101 = 1101

25&30

"""XOR ^"""

12 ^ 13

"""LEFT SHIFT <<"""

10 <<2
# 1010.0000 = 101000.0000
# SHIFT THESE 4 DIGITS LEFT SIDE

0B101000

"""RIGHT SHIFT >>"""

10>>2
# 1010.000 = 10

# THESE THINGS WILL BE USEFULL IN SCIENTIFIC CALCULATIONS

"""MATH FUNCTIONS"""

import math

x = math.sqrt(25)
x

x = math.pi
x

x = math.nan
x

x = 3.4
print(math.floor(x))
print(math.ceil(x))

import math as m 
x = m.pi

x

from math import sqrt ,pow

sqrt(9)

help("math")

"""# USER INPUT"""

x = input("give a number")

x = int(input("give a number"))

ch = input()[0]
# will only save 1st character from the input to ch

result = eval(input("enter an expression"))

# to get the inputs from same line , and add from command prompt , these are 
# used to save files in this way , when opened and entered numbers , this 
# syntax will takes those values and store
import sys
x = int(sys.argv[1])
y = int(sys.argv[2])
print(x+y)

"""# IF ELSE CONDITIONALS"""

if True :
  print("im true")

# indentation is required 
# a tab is 4 spaces 
# just press a tab instead of 4 spaces

"""#WHILE LOOPS"""

i = 0
while i<4 : 
  print("yo")
  i += 1

i = 0
while i<4 :
  print("telusko",end="")
  j =1 
  while j <4 :
    print("rocks",end="")
    j += 1
  i +=1
  print()

"""#FOR LOOPS"""

x = [1,2,3,4]
for i in x :
  print(i)

x = [1,2,3,4]
for i in x :
  print(" "*(4-i)+'#'*i)

for i in [1,2,3,4]:
  print(i)

x=0
for i in range(10):
  x += 1

N = int(input())
k = str(N)
even = odd =
for i in k :
  print(i)

n = int(input())
t = str(n)
inv = ''
for i in range(1,len(t)+1) :
  inv = inv + t[-i]
print(int(inv))

"""# BREAK CONTINUE PASS"""

x= int(input("how many candies you want?"))
i = 0
while i <=x :
  print("candy")
  i +=1

for i in range(x):
  print("candy")

"""BREAK"""

av = 5
x= int(input("how many candies you want?"))
i = 1
while i <=x :
  if i>av:
    print("OUT OF STOCK")
    break

  print("candy")
  i +=1
print("bye")

# BREAK IS USED TO EXIT OUT OF A LOOP

"""CONTINUE"""

x = int(input("enter a number:"))

i = 1
for i in range(1,x+1):
  if i%3 == 0:
    continue
  
  print(i)

print("bye")
# will skip all the statements below it 
# it'll go back to next itteration

x = int(input())

i = 1
while i <= x:
    if i % 3 == 0:
        i += 1
        continue
    print(i)
    i += 1

print("bye")

"""PASS"""

for i in range(1,11):
  if i%2!=0:
    pass
  else :
    print(i)

# will just carry on without doing anything in this condition

i = 1
while i<=10:
  if i%2!=0 :
    pass
  else:
    print(i)
  i+=1

"""BREAK VS CONTINUE VS PASS"""

for i in range(1,10):
  if i%2==0 :
    break
  print(i)

for i in range(1,10):
  if i%2==0 :
    continue
  print(i)

# continue skipped the itteration

for i in range(1,10):
  if i%2==0 :
    pass
  print(i)
# pass just went on to the next line of code 
# this is used in case there are no other statement

def fun():
  pass

a = 0 
# pass is used here to fill something under that function

"""# PATTERN PRINTING

"""

for i in range(4):
  print("# "*4)

for i in range(4):
  for j in range(4):
    print('# ', end="")
  print()

# loop for j is controlling number of hashes in a row

for i in range(4):
  for j in range(i+1):
    print('#',end="")
  print()

for i in range(4):
  print("# "*(i+1))

for i in range(4):
  for j in range(1,4):
    print("#"*j)

for i in range(5):
  print(" "*(4-i) + "#"*i)

for i in range(5):
  print("# "*(4-i))

for i in range(5):
  for j in range(4-i):
    print("# " , end="")
  print()

"""#FOR ELSE"""

# WE CAN USE ELSE IN A FOR LOOP WHEN WE HAVE AN IF CONDITIONALS WITH 
#A BREAK STEATEMENT

A = [13,24,25,77,90]
for i in A :

  if i%5==0 :
    print(i)
    break

else :
  print("not found")

#we used else for a for loop , if we had put it in if loop , every iteration we
#would have got "not found" printed
## THIS WILL ONLY WORK IN CASE OF BREAK

"""#IS PRIME"""

x=int(input("enter a number to check if its prime"))

for i in range(2,x):
  if x%i==0:
    print("not prime")
    break
else:
  print("prime")

"""#ARRAYS"""

# SIMILAR TO LISTS 
# BUT ALL ELEMENTS SHD BE OF SAME DATA TYPES

import array as arr
A = arr.array('i',[5,9,8,4,2])
print(A)

#A = arr.array('i',[5,9,8.5,4,2])
#print(A)

A = arr.array('i',[5,9,-8,4,2])
print(A)

"""INBUILT FUNCTIONS"""

print(A.buffer_info)

print(A.buffer_info())

print(A.typecode)

A.reverse()

A

A[0]

for i in A:
  print(i)

# copying the array

newarray = arr.array(A.typecode,(a for a in A))

newarray

newarray2 = arr.array(A.typecode,(a*a for a in A))

newarray2

# self made
len = int(input("length of array:"))
typecode = input("typecode")
elements = []
for i in range(len):
  elements.append(int(input("enter elements to append")))

b = arr.array(typecode,(a for a in elements))
print(b)

# telusko made
from array import *
arr = array('i',[])

n = int(input("enter length of array:"))
for i in range(n):
  x = int(input("enter next value"))
  arr.append(x)

print(arr)

"""GETTING INDEX NUMBER"""

from array import *
arr = array('i',[])

n = int(input("enter length of array:"))
for i in range(n):
  x = int(input("enter next value"))
  arr.append(x)

print(arr)

val = int(input("enter the value for search"))

for i in range(n):

  if arr[i]==val:
    print("index of the value is:",i)
    break
  
else:
  print("value not found in list")

# direct function
print(arr.index(val))

"""#NUMPY"""

# THERE ARE DIFFERENT TYPES OF ARRAYS
# MULTI DIMENTIONAL ARRAYS TOO
# EXAMPLE : MATRIX

arr = array('i',[1,2,3],[3,4,5])
# the array package doesnt support multi-dimentional
# for this purpose , WE USE NUMPY

print("HELLO WORLD")

# to install external package in idle
# type this in cmd 
# pip3 install numpy

from numpy import *
# this will import all the functions in numpy 
#dont need to call the module everytime"

arr = array([1,2,3,4,5])
print(arr)

"""CREATING ARRAYS IN NUMPY"""

# WAYS OF CREATING ARRAYS IN NUMPY

"""ARRAY()"""

from numpy import *
arr = array([1,2,3,4,5])
print(arr)

print(arr.dtype)

arr1 = array([1,2,3.4,5])
print(arr1.dtype)
print(arr1)
# all elements shd be same datatype

arr2 = array([1,2,3,4,5],float)
print(arr2)

"""LINSPACE()"""

a = linspace(0,16,3)# 3 will break the path from 0 to 16 in 3 parts
print(a)

a = linspace(0,16)
print(a)
# by default it takes 50 paths

"""ARANGE()"""

a = arange(1,15,2)# here it is steps i.e like range but in arrays so a_range arange

a

"""LOGSPACE()"""

a = logspace(1,40,5) #divides with exponentially decreased space
print(a)

"""ZEROS() AND ONES()"""

# ALL ELEMENTS WILL BE ZEROES
a = zeros(5,int)
b = ones(4,float)
print(a,b)

"""#OPERATIONS IN ARRAYS"""

arr = array([1,2,3,4,5])

arr = arr +5 # adding 5 to each elements
print(arr)

"""VECTORIZED OPERATION"""

#ADDING TWO ARRAYS
arr1 = array([1,1,1,1,1])

print([arr+arr1])

# ALSO AN PERFORM ALL MATH OPERATIONS

print(sin(arr))

print(log(arr))

print(sqrt(arr))

print(sum(arr))

print(min(arr))

print(sort(arr))

print(concatenate([arr1,arr]))

"""COPYING ARRAY"""

arr2 = arr1
print(arr2)

print(id(arr1)) # aliasing
print(id(arr2))

arr2 = arr1.view()
print(id(arr1)) # changed the address
print(id(arr2))

# shallow copy ( arr2 is dependent on arr1)
# deep copy

arr1[1] = 7 # SHALLOW COPYING
print(arr1)
print(arr2)

"""DEEP COPY"""

arr3 = arr1.copy()
arr1[2] = 4
print(arr1)
print(arr3)

print(id(arr1))
print(id(arr3))

"""# MATRIX"""

# ITS A TWO DIMENTIONAL ARRAY 
from numpy import *

arr = array([[1,2,3],[4,5,6]])

print(arr)

"""ATTRIBUTES"""

print(arr.ndim)

print(arr.shape)

arr1 = arr.flatten()
print(arr1)

arr3 = arr1.reshape(3,2)

arr3

arr3 = arr3.reshape(2,3)
arr3

arr4 = array([1,1,1,2,2,2,3,3,3,4,4,4])
arr4 = arr4.reshape(2,2,3)# RESHAPES AND GIVES AN ARRAY CONTAINING 2 MATRICES OF (2,3)
arr4

m = matrix(arr3)
print(m)#NOW THIS IS A MATRIX AND NOW WE CAN PERFORM MATRIX OPERATIONS

# ALSO
m = matrix('1 2 3 4;5 6 7 8')
print(m)

print(matrix('1 2;2 3;3 4;4 5'))

print(m.diagonal)

print(m.argmax)

m1 = matrix('1 2 3 ; 1 1 1; 2 2 2')
m2 = matrix('2 2 2;3 3 3;1 1 1')
print(m1+m2)
print(m1*m2)

print(m1+2)

m = matrix(['1 1 1;2 2 2 ;3 3 3'])

"""#FUNCTIONS"""

# IF ANY TASK IS USED IN MANY PLACES 
# INSTEAD OF USING THE SAME SET OF INSTRUCTIONS , WE USE FUNCTION
# WE DEFINE A FUNCTION , GIVE IT THE SAME SET OF CODES 
# WE CAN JUST CALL THIS WITH A NAME INSTEAD OF WRITING THE SAME CODES AGAIN

def print_hello():
    return ("hello")
  
print_hello()

def add_sub(x,y):
  
    a = x+y
    b = x-y
    return a,b


result = add_sub(2,1)
print(result)

"""ARGUMENTS/PARAMETERS"""

#PASSING PARAMETERS
#PASS BY REFERENCE AND PASS BY VALUE

def update(x):
  x = 8
  print("x",x)

a = 10
update(a)
print("a",a) # it did not change a 
# just updated x
# here we are pasing by value only and not the reference

# passing by referrence is passing the address 
#PYHTON DOESNT HAVE THESE CONCEPTS
#EVERYTHING IN PYHTON ARE OBJECTS

def update(x):
  print(id(x))
  x = 8
  print(id(x))
  print("x",x)

a = 10
print(id(a))
update(a)
print("a",a) # VALUE OF A DOESNT CHANGE

def update(x):
  print(id(x))
  x[1] = 25
  print(id(x))
  print("x",x)

a = [1,2,3]
print(id(a))
update(a)
print("a",a) # ELEMENTS IN LIST A GOT CHANGED BUT ADDRESS REMAINS SAME
# LISTS ARE MUTABLE

"""TYPES OF ARGUMENTS"""

def add(a,b): # FORMAL ARGUMENTS( WHEN ARGUMENTS ARE BEING DEFINED)
  c = a+b
  print(c)

add(2,4) # ACTUAL ARGUMENTS (WHEN ARGUMENTS ARE BEING GIVEN TO THE FUNCTION WHEN CALLED)

# 4 TYPES OF ACTUAL ARGUMENTS
# POSITION
#KEYWORD
#DEFAULT
#VARIABLE LENGTH

def person(name,age):
  print(name)
  print(age-5)

person('navin',28)

# here each arguments shd go to specific formal ones 
# therefore called POSITIONAL ARGUMENTS
person(28,'navin')# this will give us an error

def person(name,age):
    print(name)
    print(age+5)


person(age=28,name='navin')
# here its called keyword arguments

def person(name,age=10): # we are giving a value to the formal arguments
    print(name)
    print(age+5)

person('navin')
# even when the actual arguments arent given , it'll go with the default one 
# in this case its DEFAULT ARGUMENTS

"""VARIABLE LENGTH"""

def sum(a,b):
  c = a+b
  print(c)

sum(2,5)

# adding multiple values 
def sum(a,*b): # b will be of variable length 
  print(a,b)
  

sum(2,4,5,6)

def sum(a,*b): # b will be of variable length 
  print(a,b)
  c = a
  for i in b:
    c += i

  print(c)
  

sum(2,4,5,6)

"""# KEYWORDED VARIABLE LENGHT ARGUMENT"""

def person(name, *data):
  print(name)
  print(data) # but here we dont know which is which 



person('navin',28,"chennai",9500524365)

# for this perpose we use KEYWORDED VARIABLE LENGHT ARGUMENT
def person(name, **data): # mentions multiple keyworded arguments might come
  print(name)
  print(data)



person('navin',age = 28,city = "chennai", ph = 9500524365)

def person(name, **data): # mentions multiple keyworded arguments might come
  print(name)
  for i in data:
    print(data[i])



person('navin',age = 28,city = "chennai", ph = 9500524365)

def person(**details):
  print(details)
  for i,j in details.items():
    print(i,'=',j)

person(name='navin',age='20',height='180')

details = {'name': 'navin', 'age': '20', 'height': '180'}
details.items()

"""#GLOBAL AND LOCAL VARIABLE"""

# THERE IS SOMETHING CALLED SCOPE 

a = 10 # this is global

def something():
  a = 15# here a is local variable
  print(a)

something()
print(a)

# GLOBAL VARIABLES CAN BE ACCESSED INSIDE FUNCTIONS TOO

a = 10

def something():

  global a 
  a = 15 # making this a global variable
  print(a)

something()

print(a)

# we cant have a same variable for local and global

a = 10
b = 11
print(id(a))
def something():
  a = 8
  
  x = globals()['a'] # accessing global variable here without changing it
  print(id(a)) # hence different address
  print(a)
  globals()['a']= 15 # changing the global variable withput changing local one

print(a)
something()
print(a)



"""#PASSING LIST TO FUNCTIONS

FORMATING PRINT
"""

def count(a):
  even=0
  odd=0
  for i in a:
    if i%2==0:
      even+=1
    else:
      odd+=1

  return even,odd

a = [1,3,2,66,57]

e,o = count(a)

print(e,o)

print('even : {} and odd : {}'.format(e,o))

"""#FIBONACCI"""

# 0 1 1 2 3 5 8 13 21 

def fib(x):

  if x == 1 :
    return 0
  
  elif x == 2 :
    return 1 

  else :
    return fib(x-1) +fib(x-2)


print(fib(4))

def fib(x):

  if x == 1 :
    return 0
  
  elif x == 2 :
    return 1 

  else :
    return fib(x-1) +fib(x-2)


def fib_series(x):

  series = []

  for i in range(1,x+1):
    series.append(fib(i))

  return series

x = fib_series(8)
print(x)

# without recurrsion

def fib(n):

  a = 0
  b = 1
  if n ==1:
    print(a)
  else:

    print(a)
    print(b)
    for i in range(3,n+1):
        c = a + b
        a = b
        b = c
        print(c)



fib(10)

def fib(n):
   a = 0
   b = 1
  
   if n==1 :
     return a

   elif n==2 :
     return b 

   else :
    c = a+b
    a = b
    b = c 
    return fib(n-1) +fib(n-2)


def fib_less_than(n) :
    i = 1
    while fib(i)<n :
      pass 
      i +=1
    return fib(i-1)

fib_less_than(2)

def fib(x):
  
  if x<=0:
    return 0

  elif x == 1 :
    return 0
  
  elif x == 2 :
    return 1 

  else :
    return fib(x-1) +fib(x-2)
    


def fib_less_than(n) :
    i = 1
    while fib(i)<n :
     i+=1
    return fib(i-1)

fib_less_than(10)

"""#FACTORIAL"""

def fact(n):
  
  if n ==0 :
    return 1

  else:
    b = 1
    for i in range(1,n+1):
      b *= i
    return b

print(fact(4))

"""#RECURRSION"""

# CALLING A FUNCTION WITHIN FUNCTION
# EXAMPLE
def fib(x):
  
  if x<=0:
    return 0

  elif x == 1 :
    return 0
  
  elif x == 2 :
    return 1 

  else :
    return fib(x-1) +fib(x-2)

# RECURRSION HAS A MAXIMUM LIMIT =1000

import sys 

print(sys.getrecursionlimit())

import sys
sys.setrecursionlimit(2000)

print(sys.getrecursionlimit())

"""# ANONYMOUS FUNCTIONS"""

# functions without a name

# called as lamda
# use this when u dont want to def it 
# use this in only one place but many times there only(iterate/traversal/etc)

f = lambda a : a*a # here a*a is a simple expression and defining it will be lengthier
print(f(5))

f = lambda a,b : a+b 
print(f(2,5))

# lambda functions can have many variables but only one expressions

"""# FILTER MAP REDUCE"""

def is_even(n):
   return n%2==0 

num = [2,4,3,6,5,9,7]

even = list(filter(is_even,num)) # filter needs a function and a iterables
print(even)

# but here the function is_even is only used once but over an iteration
# instead we use lambda funtions

num = [2,3,4,5,6,7]

even = list(filter(lambda a:a%2==0 , num)) 
# here lambda function takes a as input returns a%2==0 
# filter interates this lambda function over num(every element of num)
# so we use this function only in this one place but many times (iterables)

print(even)

num = [2,3,4,5,6,7]

double = list(map(lambda a : a*2,num))

print(double)

from functools import reduce
num = [2,3,4,5,6,7]

sum  = reduce(lambda a,b: a+b,num)

print(sum)

"""#DECORATORS"""

def div(a,b):
  return a/b

div(4,2)

def div(a,b):
  if a<b:
    a,b = b,a

  return a/b

div(4,2)

# can we do this without changing the actual function ??
# that's where DECORATORS come into play
# ADDING EXTRA FEATURES FOR A FUNCTION OUTSIDE THEM

def div(a,b):
  print(a/b)

def smart_div(func):

  def inner(a,b):
    
    if a<b :
      a,b = b,a
    return func(a,b)

  return inner

div = smart_div(div)

div(2,4)

# THIS IS ONLY POSSIBLE IN PYTHON

"""#MODULES"""

#instead of writing big big lines of code on a single file 
# we can divide it into subparts for easy debugging and readability
# these subparts are called as MODULES

a = 9
b = 7 

from google.colab import drive
drive.mount('/content/drive')

import sys
sys.path.insert(0,'/content/drive/My Drive')



"""# SPL VARIABLE (__name__)"""

# double underscore is a diff concept
# __name__ is a special variable in python

print(__name__)

# main is the starting point of execution

# the first module in a project starts with __name__ == __main__

# importing Module here 
# import Module 
# now everything on Module will come here 
# print(" demo say :" + __name__)
# this Module getting run here will print hello Module 
# instead of hello__main__

# if another Module is used here it'll print its name with __name__ variable 
# same file will print __main__ for __name__

"""PY FILE 1"""

def main():
  print("hello")
  print("welcome user")

if __name__ == '__main__':
  main()

"""PY FILE 2"""

# import PY FILE 1 

print("it a good day")

#now even when the file 1 in imported in file 2 
# it didnt print the commands because of the condition 
# we can use this __name__ variable to check if the module is our main file 
# and to prevent command execution in lack there of



"""# OOP

INTRO
"""

# PYTHON IS AN OBJECT ORIENTED PROGRAMMING
# ALSO SUPPORTS FUNCTIONAL PROGRAMMING (ACHIEVING TASKS)
# ALSO SUPPORTS PROCEDURAL ORIENTED PROGRAMMING

# SOLVING REAL WORLD PROBLEMS WITH VIRTUAL WORLD SOLUTIONS
# IN REAL WORLD , EVERYTHING IS AN OBJECT 
# EVERY OBJECT WILL HAVE ATTRIBUTES AND BEHAVIORS / PROPERTIES

# OBJECTS DO SOMETHING BASED ON THEIR KNOWLEDGE

# THIS KNOWLEDGE IS STORED AS DATA IN VARIABLES
# THE BEHAVIOR OF AN OBJECTS IS STORED IN METHODS
# FUNCTIONS IN OOP IS "METHOD"

"""CLASS"""

# all objects are manufactored by some company
# design is important
# Classes are used to create user-defined data structures

# design of an object is called CLASS in OOP
# also called instance of a class is an object

"""# CLASS AND OBJECT"""

# defining a class

class computer:
  # put attributes(variables) and behaviors(Methods/functions)
  def config(self):
    print("i5,16gb,1TB")


a = 5 # int 
print(type(a))
b = 'rt' #str
print(type(b))

comp1 = computer() # now comp1 belongs to class computer

print(type(comp1))




# since the class is defined in the same file , it is showing name as __main__
# int and str are inbuilt classes

class computer:

  def config():
    print("i5,16gb,1TB")

comp1 = computer()

computer.config()

class computer: # computer is a class 

  def config(self): # config is a method(function)/behavior
    print("i5,16gb,1TB")

comp1 = computer()
comp2 = computer()

comp1.config()
comp2.config()

"""# INIT METHOD"""

# __init__ : special method 

class computer:

  def __init__(self):
    print("in init")


  def config(self):
    print("i5,16gb,1TB")

comp1 = computer() # here also there is an argument that is getting passed , that is the name of the object itself
comp2 = computer() # by default calls init method 
# comp1 or comp2 gets passed as arguments to self

comp1.config()
comp2.config()

class computer:

  def __init__(self,cpu,ram):
    self.cpu = cpu # self is refering to the object 
    self.ram = ram # these are nothing but the attributes
    


  def config(self):
    print("config is:",self.cpu,self.ram)


comp1 = computer('i5',16)
comp2 = computer("ryzen",8)# 3 arguments are getting passed (comp2,ryzen,8)

comp1.config()

comp2.config()

"""#CONSTRUCTOR"""

# __init__  is a constructor

class computer:
  pass



c1 = computer() # stored in heap momory (all objects are)

print(id(c1))

c2 = computer() 
print(id(c2))

# it is creating new new objects
# new addresses
# size depends on attributes / variables
# CONSTRUCTOR allocates memory

class computer:

  def __init__(self):
    self.name = 'navin'
    self.age = 20

c1 = computer()
c2 = computer()

print(c1.name)
print(c2.name)

print(id(c1))
print(id(c2))

c1.name = 'subbu'
print(c1.name)

"""# SELF"""

class computer:

  def __init__(self):
    self.name = 'navin'
    self.age = 20

  def update(self):
    self.age = 25

c1 = computer()
c2 = computer()

c1.update() # even though we didnt mention c1 in argument self will take that
print(c1.age)

if c1.age == c2.age :
  print("they are same age")

class computer:

  def __init__(self):
    self.name = 'navin'
    self.age = 20

  def update(self):
    self.age = 25

  def compare(self,other):
    if self.age == other.age :
      return True
    else :
      return False

c1 = computer()
c2 = computer()

c1.compare(c2)

c2.age = 30
c2.compare(c1) # c2 gets passed as self

"""# TYPES OF VARIABLES IN OOP"""

# INSTANCE AND CLASS(STATIC) VARIABLE

class car:
  def __init__(self):
    self.mil = 10
    self.com = 'BMW' #these are instance variable
    # i.e it changes for every object
    # we also called objects as instance of a class

c1 = car()
c2 = car()
c2.com = "AUDI"
print(c1.com)
print(c2.com)

# can there be a variable constant for all objects??
# that is static variable

# defining a variable outside init will become statis/class variables
class car:

  wheels = 4 # class variable 

  def __init__(self):
    self.mil = 10
    self.com = 'BMW' #these are instance variable
    # i.e it changes for every object
    # we also called objects as instance of a class

c1 = car()
c2 = car()
c2.com = "AUDI"

print(car.wheels)

print(c2.wheels)
print(c1.wheels)

car.wheels = 5 # changing this changes to every object and not in particular instance

print(c2.wheels)
print(c1.wheels)

"""#TYPES OF METHODS"""

# three types 
# INSTANCE = 
        #ACCESSORS (JUST FETCHING THE INSTANCE VARIABLES)
        #MUTATORS (UPDATING THE INSTANCE VARIABLE / MODIFYING THEM)
 
# CLASS
# STATIC
# class and static is not same here

"""INSTANCE"""

class student :

  school = 'CPS' # class/static variable

  def __init__(self,m1,m2,m3):

    self.m1 = m1 # instance variable
    self.m2 = m2
    self.m3 = m3

  def avg(self) : # instance method as it uses objects
    return (self.m1 + self.m2 +self.m3)/3 # ACCESSOR INSTANCE METHOD 
    # JUST USES THE VARIABLES AND GIVING OTHER VALUE

  def get_m1(self):
    return self.m1 # ACCESSORS 

  def set_m1(self,value):
    self.m1 = value # MUTATORS

  



s1 = student(40,50,60)
s2 = student(24,66,89)

print()

"""#CLASS  METHOD"""

# method that uses a class variable

class student :

  school = 'CPS' # class/static variable

  def __init__(self,m1,m2,m3):

    self.m1 = m1 # instance variable
    self.m2 = m2
    self.m3 = m3

  def avg(self) : # instance method as it uses objects
    return (self.m1 + self.m2 +self.m3)/3 # ACCESSOR INSTANCE METHOD 
    # JUST USES THE VARIABLES AND GIVING OTHER VALUE

  @classmethod # this decorator is required
  def info(cls):
    return cls.school 

  



s1 = student(40,50,60)
s2 = student(24,66,89)

print(student.info())

class student :

  school = 'CPS' # class/static variable

  def __init__(self,m1,m2,m3):

    self.sub1 = m1 # instance variable
    self.sub2 = m2
    self.sub3 = m3

  def avg(self) : # instance method as it uses objects
    return (self.m1 + self.m2 +self.m3)/3 # ACCESSOR INSTANCE METHOD 
    # JUST USES THE VARIABLES AND GIVING OTHER VALUE

   
  def getschool():
    print ("this is student class. . in abc module")

  



s1 = student()
s2 = student(24,66,89)

s2.avg()

print(student.getschool())

a =[]
a.append(3)

"""# INNER CLASS """

# class inside a class

class student :

  def __init__(self,name,rollno):
    self.name = name
    self.rollno = rollno

  def show(self):
    print(self.name,self.rollno)

s1 = student('navin',2)
s2 = student('jenny',3)

s1.show()

class student :

  def __init__(self,name,rollno):
    self.name = name
    self.rollno = rollno
    self.lap = self.laptop()

  def show(self):
    print(self.name,self.rollno)

  class laptop:

    def __init__(self):
      self.brand = "HP"
      self.cpu = 'i5'
      self.ram = 8

    def show(self):
      print(self.brand,self.cpu,self.ram)


s1 = student('navin',2)
s2 = student('jenny',3)


s1.lap.brand

lap1 = student.laptop()

lap1.show()

s1.show()

lap1 = s1.lap
lap2 = s2.lap # while accessing inner class we shd always 
print(id(lap1))
print(id(lap2))

"""#INHERITANCE"""

# PARENTS INHERIT THEIR OBJECT TO THIER GENERATIONS
# super class and sub class

class A :
  def feature1(self):
    print("feature1working")

  def feature2(self):
    print("feature2working")
class B :
  def feature3(self):
    print("feature2working")

  def feature4(self):
    print("feature4working")

a1 = A()
b1 =  b()
# here for object b1 , you can only have features  3 and 4 
a1.feature1()
a1.feature2()

"""SINGLE LEVEL INTERITENCE"""

class A :
  def feature1(self):
    print("feature1working")

  def feature2(self):
    print("feature2working")

class B(A) : # class B inherits class A
# meaning all of features of class a can also be accesible now for an object in classB
  def feature3(self):
    print("feature2working")

  def feature4(self):
    print("feature4working")

# A is super class B is subclass
a1 = A()
b1 = B() # can have all 4 features

b1.feature2()
# THIS IS SINGLE LEVEL INTERITENCE

"""MULTI LEVEL INHERTANCE"""

# MULTI LEVEL INHERTANCE
class A :
  def feature1(self):
    print("feature1working")

  def feature2(self):
    print("feature2working")
class B(A) :
  def feature3(self):
    print("feature2working")

  def feature4(self):
    print("feature4working")

class C(B) :
  def feature5(self):
    print("feature5working")

c1 = C()
c1.feature2()

"""MULTIPLE INHERTANCE"""

class A :
  def feature1(self):
    print("feature1working")

  def feature2(self):
    print("feature2working")
class B() :
  def feature3(self):
    print("feature2working")

  def feature4(self):
    print("feature4working")

class C(A,B) : # inherits from multiple super classes
  def feature5(self):
    print("feature5working")

"""CONSTRUCTOR IN INHERITANCE"""

class A :
  def __init__(self):
    print("inA")

  def feature1(self):
    print("feature1working")

  def feature2(self):
    print("feature2working")

class B(A) :
  def feature3(self):
    print("feature2working")

  def feature4(self):
    print("feature4working")

b1 = B()
# still calls the constructor of A

class A :
  def __init__(self):
    print("inA")

  def feature1(self):
    print("feature1working")

  def feature2(self):
    print("feature2working")

class B(A) :
  def __init__(self):
    print("inB")

  def feature3(self):
    print("feature2working")

  def feature4(self):
    print("feature4working")

b1 = B()
# doesn't take the contructor in A as it already in B 
# can we call both init ???

# super()

class A :
  def __init__(self):
    print("inA")

  def feature1(self):
    print("feature1working")

  def feature2(self):
    print("feature2working")

class B(A) :
  def __init__(self):
    super().__init__()
    print("inB")

  def feature3(self):
    print("feature2working")

  def feature4(self):
    print("feature4working")

b = B()
# accessed both init

class A :
  def feature1(self):
    print("feature1working")

  def feature2(self):
    print("feature2working")
class B() :
  def feature3(self):
    print("feature2working")

  def feature4(self):
    print("feature4working")

class C(A,B) : # inherits from multiple super classes
  def __init__(self):
    print("in C init")
  def feature5(self):
    print("feature5working")

c = C()

class A :
  def __init__(self):
    print("inA")

  def feature1(self):
    print("feature1Aworking")

  def feature2(self):
    print("feature2working")

class B() :
  def __init__(self):
    print("inB")

  def feature1(self):
    print("feature1Bworking")

  def feature4(self):
    print("feature4working")

class C(A,B) : # inherits from multiple super classes
  def __init__(self):
    super().__init__()
    print("in C init")
  def feature5(self):
    print("feature5working")

c = C()

# it does'nt go to B , it goes to A 
# as A is given in left
# MRO - METHOD RESOLUTION ORDER (FROM LEFT TO RIGHT)

class A :
  def __init__(self):
    print("inA")

  def feature1(self):
    print("feature1Aworking")

  def feature2(self):
    print("feature2working")

class B() :
  def __init__(self):
    print("inB")

  def feature1(self):# SAME FEATURE NAME
    print("feature1Bworking")

  def feature4(self):
    print("feature4working")

class C(A,B) : # inherits from multiple super classes
  def __init__(self):
    super().__init__()
    print("in C init")
  def feature5(self):
    print("feature5working")

c = C()
c.feature1()

class A :
  def __init__(self):
    print("inA")

  def feature1(self):
    print("feature1Aworking")

  def feature2(self):
    print("feature2working")

class B() :
  def __init__(self):
    print("inB")

  def feature1(self):# SAME FEATURE NAME
    print("feature1Bworking")

  def feature4(self):
    print("feature4working")

class C(B,A) : # B IS GIVEN MORE PRIORITY
  def __init__(self):
    super().__init__()
    print("in C init")
  def feature5(self):
    print("feature5working")

c = C()
c.feature1()
# B GIVEN MORE PREFERENCE

# WE CAN ALSO USE THIS super() to call other methods



"""# POLYMORPHISM"""

# poly - many
# morph - form 
# many forms

# objects have multiple forms

# duck typing
# operator overloading
# method overloading
# method overriding

"""DUCK TYPING"""

# IF A BIRD WALKS , SQUAKS , SWIMS LIKE A DUCK
# THEN THAT BIRD IS A DUCK

# ANY OBJECT THAT BEHEAVES LIKE A DUCK IS A DUCK

x = 5 
# dynamic type # can mention types later
# x is just a name to 5
# type(x) gives type of 5

y = 'navin'
# y is juat a name to navin

class pycharm:

  def execute(self):
    print("compiling")
    print("running")

class hotsause:

  def execute(self):
    print("spellcheck")
    print("coolnesscheck")

class laptop:

  def code(self,ide):
    ide.execute()

ide1 = pycharm()
ide2 = hotsause()

c = laptop()

c.code(ide2)# type of ide is hotsause here

d = laptop()
ide1 = pycharm()
d.code(ide1)
# type of ide is pycharm here

# no matter which class the ide is from 
# as long as that class has execute method , itll run that method

# the object ide here has similar behavior/method execute
# so the object is DUCK 
# DUCK TYPING

"""OPERATOR OVERLOADING"""

# OPERATORS + - * /

a = 5
b = 'world'

# cant a+b

a = 5
b = 5
print(int.__add__(a,b) )

a = '5'
b = '6'

print(str.__add__(a,b))

class student:

  def __init__(self,m1,m2):
    self.m1 = m1
    self.m2 = m2
  
  def __add__(self,other):
    m1 = self.m1 + other.m1
    m2 = self.m2 + other.m2
    s3 = student(m1,m2)

    return s3

  def __sub__(self,other):

    m1 = self.m1 - other.m1
    m2 = self.m2 - other.m2
    s=  student(m1,m2)

    return s

  def show(self):
    print(self.m1 , self.m2)



s1 = student(45,66)
s2 = student(90,33)
s3 = s1+s2 # -> student.__add__(s1,s2)
s3.show() 

# we defined method __add__ which works as + 
# its called operator overloading
# as the method behaves as an operator and a method
# 2 forms - polymorphism


# overloading subtraction operator

s4 = s1-s2 
s4.show()

# the int and str knows what is + 
# the student class didn't know 
# so we did a operator overload

print(s1)
# this doesn't print the value in object 
# rather prints address

a = 0
a.__str__()

print(a.__str__())

print(s1.__str__()) 
# this method is inbuilt and its giving address rather than value

"""METHOD OVERRIDING"""

# CHANGING THE ALDREASY EXISTING INBUILT METHOD 
# OVERIDING THE INBUIT METHOD

class student:

  def __init__(self,m1,m2):
    self.m1 = m1
    self.m2 = m2
  
  def __add__(self,other):
    m1 = self.m1 + other.m1
    m2 = self.m2 + other.m2
    s3 = student(m1,m2)

    return s3

  def __sub__(self,other):

    m1 = self.m1 - other.m1
    m2 = self.m2 - other.m2
    s=  student(m1,m2)

    return s

  def show(self):
    print(self.m1 , self.m2)

  def __str__(self):
    return "{} {} ".format(self.m1 , self.m2)



s1 = student(45,66)
print(s1)

s2 = student(56,75)
print(s2)

"""METHOD OVERLOADING"""

# method overloading isnt there in python
# for example 

# class student :
#     def avg(a,b)
#     def avg(a,b,c) this is method overloading

# because in python we cant create two methods with same name

class student:

  def __init__(self,m1,m2):
    self.m1 = m1
    self.m2 = m2

  def sum(self,a,b):
    s = a+b

    return s
  

s1 = student(58,69)

print(s1.sum(5,9)) # we cant give 3 values 
# we cant define a method we same name too

class student:

  def __init__(self,m1,m2):
    self.m1 = m1
    self.m2 = m2

  def sum(self,a=None,b=None,c=None):
    s = a+b+c

    return s
  

s1 = student(58,69)

print(s1.sum(5,9,8))

print(s1.sum(5,6))

class student:

  def __init__(self,m1,m2):
    self.m1 = m1
    self.m2 = m2

  def sum(self,a=0,b=0,c=0):
    
    s = a+b+c

    return s
  

s1 = student(58,69)

print(s1.sum(5,9,8))

print(s1.sum(5,6))

"""METHOD OVERRIDING"""

class A:
  def show(self):
    print("in A show")

class B(A):
  pass

a1 = B()
a1.show()

class A:
  def show(self):
    print("in A show")

class B(A):
  def show(self):
    print("in B show") # this method overrides the method parent class

  

a1 = B()
a1.show()



"""# ABSTRACT CLASSES AND METHODS"""

# what?

class computer:
  def process(self):
    print("running") # if u want to keep it empty

class computer:
  def process(self):
    pass
    
#this is an abstract method 
com = computer()
com.process() # will run normally

#making it an abstract class
from abc import ABC,absbtractmethod

class computer(ABC):
  @abstractmethod
  def process(self):
    pass

class laptop(computer):
    pass



    

# abstract class will have atleast on abstract method

#

class computer():
  pass

c = computer()

# we will use this to block a method 
# make it an abstract to avoid it from running



"""# EXCEPTIONAL HANDLING"""

# COMPILE TIME
# LOGICAL
# RUN TIME

"""COMPILE ERRORS"""

# SYNTAX ERROR ( MISSING COLONS , SPELLING MISTAKES )

"""LOGICAL ERRORS"""

# WRONG LOGIC
# it'll compile correctly anf give a wrong output

"""RUN TIME ERROR"""

# user gave invalid input
# 6 divide by 0 where 6 and 0 are given by user

# easier handling is for compile

# concepts discusses that 
# even at a time of errors, the execution should not stop

a = 5 # normal statements ( not give error)
b = 0 
print(a/b) # critical statements ( prone to give error )

# how to solve this issue 
# we dont want the program to stop

a = 5
b = 0 

try :
  print(a/b)
except Exception: # exception handled
  print("b can't be 0 ")

a = 5
b = 0 

try :
  print(a/b)
except Exception as e : # exception handled by printed the exception
  print("b can't be 0 ",e)

# whenever u open a resource , always close the resource
# irl example is fridge 
# if after opening , someone calls , u close it and go right

a = 5
b = 0 

try :
  print("resource open")
  print(a/b)
  
except Exception as e : # exception handled by printed the exception
  print("b can't be 0 ",e)

a = 5
b = 2.5

try :
  print("resource open :")
  print(a/b)
  
except Exception as e : # exception handled by printed the exception
  print("b can't be 0 ",e)
  

finally:
  print(" : resource closed")

a = 5
b = 2.5

try :
  print("resource open :")
  print(a/b)
  k = int(input())
  print(k)

  
except Exception as e : # exception handled by printed the exception
  print("b can't be 0 ",e)
  

finally:
  print(" : resource closed")

a = 5
b = 2.5
k = int(input())
print(k)

try :
  print("resource open :")
  print(a/b)
  

  
except Exception as e : # exception handled by printed the exception
  print("b can't be 0 ",e)
  

finally:
  print(" : resource closed")

a = 5
b = 2

try :
  print("resource open :")
  print(a/b)
  k = int(input())
  print(k)

  
except ZeroDivisionError as e :# only for zero error
  print("b can't be 0 ",e)

except ValueError as v :
  print("invalid input type",v)

except Exception as e:
  print("something went wrong")


finally:
  print(" : resource closed")

a = 5
b = 0

try :
  print("resource open :")
  print(a/b)
  k = int(input()) # it didnt even execute this as error occured in previous statement only
  print(k)

  
except ZeroDivisionError as e :
  print("b can't be 0 ",e)

except ValueError as v :
  print("invalid input type",v)

except Exception as e:
  print("something went wrong")


finally:
  print(" : resource closed")



"""#MULTITHREADING"""

# THREADS ?
# big tasks is broken down into smaller parts called threads 
# and when run simultaneously its called multi-threading

# in an application 
# so many events shd happen at a same time

class hello :
  def run(self):
    for i in range(6):
      print("hello")

class hi:
  def run(self):
    for i in range(6):
      print("hi")

t1 = hello()
t2 = hi()

t1.run()
t2.run() # first 5 times helloo and then 5 times hi

from threading import *
from time import sleep

from threading import *
from time import sleep

class hello(Thread) :

  def run(self): # inside thread class there is run method
    for i in range(100):
      print("hello")
      sleep(1)

class hi(Thread):

  def run(self):
    for i in range(100):
      print("hi")
      sleep(1)

t1 = hello()
t2 = hi()

t1.start()
sleep(0.2)
t2.start()
# but the system is very fast to see the difference

# because it is fast 
# both can go at a same time too , which is called collision

# refer to MultiThreadingTelusko in pycharm

"""# COMMENTS"""

# single line

# multi
# line 
# comments

"""DOCUMENTATION

THIS IS USED AS DOCUMENTATION

#COMPILER AND INTERPRETER
"""

# PYTHON IS BOTH

# COMPILER
# c++ and java are high level languages (compiled language)
# before executing , it has to compile and convert into machine language

# INTERPRETED 
# line by line execution 
# python is interpreted

# potability
# can run in any machine 
# codes are independent of machine

# python is actually compiled to bite code (for potability)
# before line by line execution

# virtual machine
# for python PVM
# this virtual machine will compile it to bite code

# in other languages u have to compile separately (addditional code)
# python does it automatically

#cpython ???

# actual implementation is actually cpython

# cpython is implemented in c language

# jpython is implemented in j language



"""# FILEHANDLING"""

# usually all the variables and datas get erased after we close the program / interpreter

# i want my data to be stored somewhere
# for this we use relational database

#Relational database # structured way to store #very complex
      #Mysql
      #oracle 

# a simple way is through texts

a = open('MyData','r')

print(f) # We don't get data inside, instead we get details about the file
#instead
print(f.read())# now we can read the data

print(f.readline()) # will print line by line
print(f.readline()) # will print the second line but with an extra line space

# this will decrease the linespace
print(f.readline(), end='')

print(f.readline())


print(f.readline(4))# will print only four characters

f1 = open('abc','w') # for writing
 # new file gets created named abc

f1.write("something")

f1 = open('abc','a') #append to already existing data

f1.write(" laptop")

f = open('MyData','r')

f1 = open('abc','a')

for data in f :
    f1.write(data) # copying from one to other

f = open('1.jpeg','rb')

for i in f:
    print(i) # for image

f = open('1.jpeg','rb')
f1 = open("2.jpeg",'wb')
for i in f:
    f1.write(i) # image has been copied



"""#ZIP"""

names = ("navin",'kiran','harsh')
comp = ("dell",'apple','ms')

zipped = zip(names,comp)

zipped

zipped = list(zip(names,comp))
zipped

zipped = set(zip(names,comp))
zipped

for (a,b) in zipped:
  print(a,b)
